
# OSI 的七层模型
OSI 七层模型一般指开放系统互连参考模型 (Open System Interconnect 简称 OSI)
是国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)联合制定的开放系
统互连参考模型,为开放式互连信息系 统提供了一种功能结构的框架。  

应用层：为应用程序提供交互服务，各种应用程序协议，比如 HTTP、HTTPS、FTP、SOCKS 安全套接字协议、DNS 域名系统、GDP 网关发现协议等等。  
表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。比如 LPP 轻量级表示协议。  
会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的，比如 SSL 安全套接字层协议、TLS 传输层安全协议、RPC 远程过程调用协议等等。 
传输层：接受上一层的数据，在必要的时候对数据进行分割，并将这些数据交给网络层，保证这些数据段有效到达对端，比如 TCP 传输控制协议、UDP 数据报协议。  
网络层：选择合适的路由和交换结点，确保数据及时传送，控制子网的运行：逻辑编址、分组传输、路由选择，比如 IP、IPV6、SLIP 等等。  
数据链路层：将网络层传下来的 IP 数据包组装成帧，并再相邻节点的链路上传送帧。物理寻址，同时将原始比特流转变为逻辑传输路线，
比如 XTP 压缩传输协议、 PPTP 点对点隧道协议等等。  
物理层：现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。机械、电子、定时接口通信信道上的原始比特流传输，比如 IEEE802.2 等等。 


# TCP/IP 4 层模型 
应用层 
传输层 
网络层 
网络接口层 



# TCP 
HTTP 在应用层，TCP 传输层，TSL or SSL 安全层，IP 网络层； 
TCP 会按序、无差错地承载 HTTP 数据，TCP 为 HTTP 提供了一条可靠的比特传输管道。
从 TCP 连接一端填入的字节会从另一端以原有顺序、正确地传送出来。
HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP 连接按序传输。
TCP 收到数据流之后，会将数据流砍成被称为段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输。 
每个 TCP 段都是由 IP 分组承载，从一个 IP 地址发送到另一个 IP 地址的。


## TCP 和 UDP 区别 
1. TCP 协议是有连接的，有连接的意思是开始传输实际数据之前 TCP 的客户端和服务器端必须通过三次握手建立连接，会话结束后也要结束连接。
而 UDP 是无连接的；
2. TCP 协议保证数据发送，按序送达，提供超时重传保证数据可靠性。
但是 UDP 不保证按序到达，甚至不能保证到达，即便是按序发送的序列，也不保证按序送到； 
3. TCP 协议所需资源多，TCP 首部需 20 个字节（不算可选项），UDP 首部字段只需 8 个字节;  
4. TCP 有流量控制和拥塞控制，UDP 没有。网络拥堵不会影响发送端的发送速率;  
5. TCP 面向的字节流的服务，UDP 面向的是报文的服务。 
TCP 应用场景： 
效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有 UDP 高。
举几个例子：文件传输、接受邮件、远程登录。 
UDP 应用场景：
效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ 聊天、在线视频、网络语音电话、广播通信（广播、多播）。 


## TCP 协议如何保证可靠性 
TCP 主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和流量控制等方法实现了可靠性传输。 
1. 检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃 TCP 段，重新发送。 
2. 序列号/确认应答：序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。 
TCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。
也就是发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。 
3. 滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。 
4. 超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。
最大超时时间是动态计算的。 
5. 拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证 TCP 可靠性的同时，提高性能。 
6. 流量控制：如果主机 A 一直向主机 B 发送数据，不考虑主机 B 的接受能力，则
可能导致主机 B 的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。
而在重传的过程中，若主机 B 的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。
所以引入流量控制机制，主机 B 通过告诉主机 A 自己接收缓冲区的大小，来使主机 A 控制发送的数据量。
流量控制与 TCP 协议报头中的窗口大小有关。


## 详细讲一下 TCP 的滑动窗口 
在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。
TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。 
为了避免这种情况，TCP 引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。 
滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。 
滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。
随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。
可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，
而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。


## 三次握手
首先 Client 端发送连接请求报文，Server 端接收连接后回复 ACK 报文，并为这次连接分配资源。
Client 端接收到 ACK 报文后也向 Server 段发送 ACK 报文，并分配资源，这样 TCP 连接就建立了。 
详细过程： 
第一次握手：起初两端都处于 CLOSED 关闭状态，Client 将标志位 SYN 置为 1，随机产生一个值 seq=x，
并将该数据包发送给 Server，Client 进入 SYN-SENT 状态，等待 Server 确认；  
第二次握手：Server 收到数据包后由标志位 SYN=1 得知 Client 请求建立连接，
Server 将标志位 SYN 和 ACK 都置为 1，ack=x+1，随机产生一个值 seq=y，并将
该数据包发送给 Client 以确认连接请求，Server 进入 SYN-RCVD 状态，此时操作系统为该 TCP 连接分配 TCP 缓存和变量；  
第三次握手：Client 收到确认后，检查 ack 是否为 x+1，ACK 是否为 1，如果正
确则将标志位 ACK 置为 1，ack=y+1，并且此时操作系统为该 TCP 连接分配 TCP
缓存和变量，并将该数据包发送给 Server，Server 检查 ack 是否为 y+1，ACK 是
否为 1，如果正确则连接建立成功，Client 和 Server 进入 ESTABLISHED 状态，
完成三次握手，随后 Client 和 Server 就可以开始传输数据。  
TCB 传输控制块 Transmission Control Block，存储每一个连接中的重要信息，如
TCP 连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号。 


## 四次挥手过程
1）A 的应用进程先向其 TCP 发出连接释放报文段（FIN=1，序号 seq=u），并停
止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认。  
2）B 收到连接释放报文段后即发出确认报文段，（ACK=1，确认号 ack=u+1，序号 seq=v），
B 进入 CLOSE-WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，A 到 B 的连接释放。  
3）A 收到 B 的确认后，进入 FIN-WAIT-2（终止等待 2）状态，等待 B 发出的连接释放报文段。  
4）B 没有要向 A 发出的数据，B 发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号 ack=u+1），
B 进入 LAST-ACK（最后确认）状态，等待 A 的确认。 
5）A 收到 B 的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），
A 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，A 才进入 CLOSED 状态。 


## TCP 协议为什么需要三次握手 
1. 通信双方都必须要维护一个序列号，去标记已经发送出去的数据包，哪些是已经被对方签收的； 
2. TCP 协议就要在一个不可靠的网络环境下，也要实现可靠的数据传输。通信双
方须要通过某种手段来实现一个可靠的数据传输通道，而三次通信是建立这样通道的最小值；
3. 防止历史的重复连接初始化造成的混乱问题，两次握手端只能选择接受或者拒绝这个连接请求。 


## 四次挥手释放连接时，等待 2MSL 的意义 
第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段
有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN 和 ACK 
报文段的确认。B 会超时重传这个 FIN 和 ACK 报文段，而 A 就能在 2MSL 时间
内收到这个重传的 ACK+FIN 报文段。接着 A 重传一次确认。  
第二，就是防止上面提到的已失效的连接请求报文段出现在本连接中，A 在发送
完最有一个 ACK 报文段后，再经过 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。 


## 为什么要 Time_Wait 
谁先关闭谁先进入 time_wait 状态可靠的终止 TCP 连接。
保证让迟来的 TCP 报文有足够的时间被识别并丢弃，让网络上的数据包自动消亡，防止旧连接初始了新的连接。


## 要是没有三次握手会怎么样 
三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。（防止历史连接初始化了连接）同步双方初始序列号 避免资源浪费 
三次握手的目的是建立可靠的通信信道，三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 


## 为什么要四次挥手？ 
TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。
当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。 
举个例子：A 和 B 打电话，通话即将结束后。 
第一次挥手 ： A 说“我没啥要说的了” 
第二次挥手 ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求B 跟着自己的节奏结束通话 
第三次挥手 ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了” 
第四次挥手 ：A 回答“知道了”，这样通话才算结束。


## 为什么需要三次握手，而不是两次？ 
主要有三个原因： 
1. 防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。 
在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，
由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。 
客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，
客户端在收到确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。 
此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入ESTABLISHED 状态，
但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。 
2. 三次握手才能让双方均确认自己和对方的发送和接收能力都正常。 
第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常； 
第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常； 
第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常； 
可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。 
3. 告知对方自己的初始序号值，并确认收到对方的初始序号值。
TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，
通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。
这两个字段的值会在初始序号值的基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。 


## 为什么要三次握手，而不是四次？ 
因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，
而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。 
第一次握手：服务端确认“自己收、客户端发”报文功能正常。 
第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。 
第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。 

三次握手建立连接时，发送方再次发送确认的必要性？ 
主要是为了防止已失效的连接请求报文段突然又传到了 B,因而产生错误。假定
出现一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某
些网络结点长时间滞留了，一直延迟到连接释放以后的某个时间才到达 B，本来
这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是
A 又发出一次 新的连接请求，于是就向 A 发出确认报文段，同意建立连接。假
定不采用三次握手，那么只要 B 发出确认，新的连接就建立了，这样一直等待 A
发来数据，B 的许多 资源就这样白白浪费了。 


## 三次握手连接阶段，最后一次 ACK 包丢失，会发生什么？ 
服务端：
第三次的 ACK 在网络中丢失，那么服务端该 TCP 连接的状态为 SYN_RECV,并且会根据 TCP 的超时重传机制，
会等待 3 秒、6 秒、12 秒后重新发送 SYN+ACK包，以便客户端重新发送 ACK 包。 
如果重发指定次数之后，仍然未收到 客户端的 ACK 应答，那么一段时间后，服务端自动关闭这个连接。 
客户端：
客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以 RS 包（Reset，标示复位，用于异常的关闭连接）响应。
此时，客户端知道第三次握手失败。 


## 为什么连接的时候是三次握手，关闭的时候却是四次握手？ 
服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段. 
接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。
服务器的 ACK 和 FIN 一般都会分开发送，从而导致多了一次，因此一共需要四次挥手。 


## CLOSE-WAIT 状态问题
客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了CLOSE-WAIT 状态。
这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 


## TIME-WAIT 状态问题
客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。
这么做有两个理由：
1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 
2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 
通信双方建立 TCP 连接后，主动关闭连接的一方就会进入 TIME_WAIT 状态。 


## 如果已经建立了连接，但是客户端出现故障了怎么办？或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？
如“服务端重发FIN 丢失”的问题。 
简而言之，通过定时器 + 超时重试机制，尝试获取确认，直到最后会自动断开连接。 
具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。
若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，
若一连发送10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。 


## TIME-WAIT 状态过多会产生什么后果？怎样处理？ 
从服务器来讲，短时间内关闭了大量的 Client 连接，就会造成服务器上出现大量的 TIME_WAIT 连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。 
从客户端来讲，客户端 TIME_WAIT 过多，就会导致端口资源被占用，因为端口就 65536 个，被占满就会导致无法创建新的连接。 
解决办法：
服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT 状态，此套
接字选项告诉内核，即使此端口正忙（处于 TIME_WAIT 状态），也请继续并重用它。 
调整系统内核参数，修改/etc/sysctl.conf 文件，
即修改 net.ipv4.tcp_tw_reuse 和 tcp_timestamps net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接，默认为 0，表示关闭； 
net.ipv4.tcp_tw_recycle = 1 表示开启 TCP 连接中 TIME-WAIT sockets 的快速回收，默认为 0，表示关闭。 
强制关闭，发送 RST 包越过 TIME_WAIT 状态，直接进入 CLOSED 状态。 


## TIME_WAIT 是服务器端的状态?还是客户端的状态?
TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态；服务器端一般设置不主动关闭连接。 
TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT 会太多，这也会消耗很多系统资源。
对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），
由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。 


## 第 2 次握手传回了 ACK，为什么还要传回 SYN？ 
服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。
回传 SYN 则是为了建立并确认从服务端到客户端的通信。 
SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。
在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，
最后客户机再以 ACK(Acknowledgement）消息响应。
这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。 


# HTTPS 原理详解 
HTTPS 是对 HTTP 的扩展，保证了通信安全，二者关系如下：HTTPS = HTTP + SSL / TLS。
HTTPS 加密、解密、验证及数据传输过程:
HTTPS 的整个通信过程可以分为两大阶段：证书验证和数据传输阶段，数据传输阶段又可以分为非对称加密和对称加密两个阶段。 
1. 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的 80 端口)。 
2. 采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，
证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。
颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。
证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。 
3. 服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，
比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏
的锁标志再点击证书就可以看到证书详细信息。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的
域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥 A。然后客户端还会生成一个随机码 KEY，并使用公钥 A 将其加密。 
5. 客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。 
6. 服务器在收到随机码 KEY 之后会使用私钥 B 将其解密。经过以上这些步骤，
客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。 
7. 服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。 
8. 双方使用对称加密愉快地传输所有数据。 


# ARP 
ARP 协议是属于网络层的协议，主要作用是实现从 IP 地址转换为 MAC 地址，
在每个主机或者路由器中都建有一个 ARP 缓存表，表中有 IP 地址及 IP 地址对应的 MAC 地址。 
ARP 的工作流程
1. 局域网内，主机 A 要向主机 B 发送 IP 数据报时，首先会在主机 A 的 ARP 缓
存表中查找是否有 IP 地址及其对应的 MAC 地址，如果有，则将 MAC 地址写入
到 MAC 帧的首部，并通过局域网将 MAC 帧发送到 MAC 地址所在的主机 B; 
2. 主机 A 的 ARP 缓存表中没有主机 B 的 IP 地址及所对应的 MAC 地址，主机
A 会在局域网内广播发送一个 ARP 请求分组，局域网内的所有主机都会受到这个 ARP 请求分组； 
3. 在看到主机 A 发送的 ARP 请求分组中有自己的 IP 地址，会向主机 A 以单播
的方式发送一个带有自己 MAC 地址的响应分组； 
4. 收到主机 B 的响应分组后，会在 ARP 缓存表中写入主机 B 的 IP 地址及其 IP地址对应的 MAC 地址； 
5. 主机 A 和主机 B 不在同一个局域网内，即使知道主机 B 的 MAC 地址也是不
能直接通信的，必须通过路由器转发到主机 B 的局域网才能通过 B 的 MAC 地
址找到主机 B。并且主机 A 和主机 B 已经可以通信的情况下，主机 A 的 ARP 缓
存表中存的并不是主机 B 的 IP 地址及其对应的 MAC，而是主机 B 的 IP 地址及
该通信链路上的下一跳路由器的 MAC 地址。 
6. 主机 A 和主机 B 不在同一局域网，这时主机 A 需要先广播找到路由器的 MAC
地址，再由此路由器找到主机 B 所在的下一跳路由器的 MAC 地址，最后这个路
由器再广播到主机 B 的 MAC 地址，建立起通信链路。 



# http
HyperText Transfer Protocol。超文本传输协议。
HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 
HTTP 协议的主要特点可概括如下： 
1.支持客户/服务器模式。
2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。
每种方法规定了客户与服务器联系的类型不同。
由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。 
3.灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。 
4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。
采用这种方式可以节省传输时间。 
5.无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。
缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
另一方面，在服务器不需要先前信息时它的应答就较快。

## HTTP 和 HTTPS 有什么区别？ 
1. 端口号：HTTP 默认是 80，HTTPS 默认是 443。 
2. URL 前缀：HTTP 的 URL 前缀是 http://，HTTPS 的 URL 前缀是 https://。
3. 安全性和资源消耗 ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。
所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。
所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。 


## http 请求方法 
HTTP 请求 8 种方法介绍 HTTP/1.1 协议中共定义了 8 种 HTTP 请求方法，HTTP
请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。
服务端也会根据不同的请求方法做不同的响应。 
### GET 
GET 请求会显示请求指定的资源。一般来说 GET 方法应该只用于数据的读取，
而不应当用于会产生副作用的非幂等的操作中。 
GET 方法请求指定的页面信息，并返回响应主体，GET 被认为是不安全的方法，因为 GET 方法会被网络蜘蛛等任意的访问。 

### HEAD
HEAD 方法与 GET 方法一样，都是向服务器发出指定资源的请求。但是，服务
器在响应 HEAD 请求时不会回传资源的内容部分，即：响应主体。这样，我们可
以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。 

### POST
POST 请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。
POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。 

### PUT
PUT 请求会身向指定资源位置上传其最新内容，PUT 方法是幂等的方法。通过
该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。 

### DELETE 
DELETE 请求用于请求服务器删除所请求 URI（统一资源标识符，Uniform 
Resource Identifier）所标识的资源。DELETE 请求后指定资源会被删除，DELETE方法也是幂等的。 

### CONNECT
CONNECT 方法是 HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器。
通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。

### OPTIONS
OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。 这个
方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用’*’来
代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。
JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用
OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许 

### TRACE 
TRACE 请求服务器回显其收到的请求信息，该方法主要用于 HTTP 请求的测试或诊断。 

HTTP/1.1 之后增加的方法
在 HTTP/1.1 标准制定之后，又陆续扩展了一些方法。其中使用中较多的是PATCH 方法： 
### PATCH
PATCH 方法出现的较晚，它在 2010 年的 RFC 5789 标准中被定义。PATCH 请
求与 PUT 请求类似，同样用于资源的更新。二者有以下两点不同： 
但 PATCH 一般用于资源的部分更新，而 PUT 一般用于资源的整体更新。 当资
源不存在时，PATCH 会创建一个新的资源，而 PUT 只会对已在资源进行更新。 


## http 请求中 get post 区别 
1. get 请求只能提交 1kb 以下的数据，post 请求可以提交大数据； GET 提交有
数据大小的限制，一般是不超过 1024 个字节，而这种说法也不完全准确，HTTP
协议并没有设定 URL 字节长度的上限，而是浏览器做了些处理，所以长度依据浏览器的不同有所不同；
POST 请求在 HTTP 协议中也没有做说明，一般来说是没有设置限制的，但是实际上浏览器也有默认值。
总体来说，少量的数据使用 GET，大量的数据使用 POST。 
2. get 请求，请求的参数会在浏览器上显示，post 请求它的数据不会再浏览器上显示（安全）； 
3. get 请求用来从服务器上获得资源，而 post 是用来向服务器提交数据；  
4. get 将表单中数据按照 name=value 的形式，添加到 action 所指向的 URL 后
面，并且两者使用"?"连接，而各个变量之间使用"&"连接；post 是将表单中的
数据放在 HTTP 协议的请求头或消息体中，传递到 action 所指向 URL； 
5. 对于 GET 方式，服务器端用 Request.QueryString 获取变量的值，对于 POST方式，服务器端用 Request.Form 获取提交的数据； 
6. GET 是幂等的，即读取同一个资源，总是得到相同的数据，POST 不是幂等的； 


 
## 列出常见的 http 状态码和意义 
状态代码有三位数字组成，第一个数字定义响应的类别，共分 5 种类型 
1xx:提示信息--表示请求接受，继续处理 
2xx:成功表示请求成功接收，理解，接受 
3xx:重定向要完成请求必须更进一步操作 
4xx:客户端错误，请求有语法错误或请求无法实现 
5xx:服务器端错误--服务器没有实现合法请求 
 
200 OK-----请求正常处理完毕 
204 No Content-----请求成功处理，没有实体的主体返回 
206 Partial Content-----GET 范围请求已成功处理 
301 Moved Permanently-----永久重定向，比如建设一个网站后，将网站的 url 变换了，重新申请一个域名， 
但是希望之前的用户访问之前 url 仍然可以访问到，就可以做一个重定向新的 url 下面。 
302 Found-----临时重定向，比如用户在未登录时访问个人中心页面，这时可以临时重定向到登录的 url 
303 See Other-----临时重定向，期望使用 GET 定向获取 
304 Not Modified-----发送的附带条件请求未满足,当客户端拥有可能过期的缓存时，会携
带缓存的标识 etag、时间等信息询问服务器缓存是否仍可复用，而 304 是告诉客户端可以复用缓存 
307 Temporary Redirect-----临时重定向，POST 不会变成 GET 
400 Bad Request-----请求报文语法错误或参数错误，服务器无法理解此请求。不作修改，客户程序就无法重复此请求 
401 Unauthorized-----需要通过 HTTP 认证，或认证失败 
403 Forbidden-----请求资源被拒绝,系统中某些页面只有在某些权限下才能访问，当用户
去访问了一个本身没有访问权限的 url，回报 403 错误 
404 Not Found-----无法找到请求资源（服务器无理由拒绝）,一般是自己输入了一个 url，
这个 url 并不合法。404 找不到，Web 服务器找不到您所请求的文件或脚本。请检查URL 以确保路径正确; 
500 Internal Server Error-----服务器故障或 Web 应用故障,比如服务器某一个函数代码出
错了，有没有捕获异常，这时候会报 500 错误。500 服务器的内部错误，Web 服务器不能执行此请求。请稍后重试此请求 
502 Bad Gateway 
此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。 
503 Service Unavailable-----服务器超负载或停机维护,系统正在维护或者服务器暂停的时候，回报 500 错误 
504 Gateway Timeout-----当服务器充当网关且无法及时获得响应时，会给出此错误响应。 


## 幂等 Idempotence 
HTTP 方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。(注意是副作用)；
一个方法被多次重复执行的时候所期望的结果要和第一次执行所期望的结果保持一致；
简单来说就是一个逻辑即使被执行多次，也不影响最终结果的一致性。 
以下两种行为都有可能导致接口被重复执行： 
a. 重复提交或者恶意攻击； 
b. 超时重试机制； 

幂等性的核心思想，其实就是保证这个接口的执行结果只影响一次，后续即使再次调用，也不能对数据产生影响。 

如何解决幂等性问题
两种思路：接口只允许调用一次，比如唯一约束、基于 redis 的锁机制；对数据的影响只会触发一次，比如乐观锁等。 
1. 使用数据库的唯一约束来实现幂等 
比如说对于数据插入的场景而言，假设我们要去创建一个订单，订单号肯定是唯一的，
如果我们多次去触发数据库的唯一约束，它就会产生异常，从而避免一个请求创建多个订单的问题； 
2. 可以使用 redis 提供的 setNX 指令；
比如我们 MQ 消息的场景，我们避免 MQ 重复消费，从而导致数据多次被修改
的问题，可以在接收 MQ 消息的时候，把这个消息通过 setNX 写入到 redis 中，一旦这个消息被消费，我们就不会再次消费； 
3. 使用状态机来实现幂等 
状态机指的是一条数据的完整的运行状态的转化流程，比如说订单的状态，因为
它的状态只会向前变更，所以多次修改同一条数据的时候，一旦状态发生变更，
那么这条数据修改造成的影响也就之后发生一次， 

GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是
N 次都没有副作用。请注意，这里强调的是一次和 N 次具有相同的副作用，而不是每次 GET 的结果相同。
GET http://www.news.com/latest-news 这个 HTTP 请求可
能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。

DELETE 方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE 
http://www.forum.com/article/4231，调用一次和 N 次对系统产生的副作用是相同的，
即删掉 id 为 4231 的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。

POST 所对应的 URI 并非创建的资源本身，而是资源的接收者。比如：POST 
http://www.forum.com/articles 的语义是在 http://www.forum.com/articles 下创建一篇帖子，
HTTP 响应中应包含帖子的创建状态以及帖子的 URI。 两次相同的 POST 请求会在服务器端创建两份资源，它们具有不同的 URI；
所以，POST 方法不具备幂等性。 
PUT 所对应的URI是要创建或更新的资源本身。
比如：PUT http://www.forum/articles/4231 的语义是创建或更新 ID 为 4231 的帖子。
对同一URI 进行多次 PUT 的副作用和一次 PUT 是相同的；因此，PUT 方法具有幂等性


## 解释一下 HTTP 长连接和短连接 
在 HTTP/1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP 操作，就建立一次连接，但任务结束就中断连接。
如果客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源，
如 JavaScript 文件、图像文件、CSS 文件等；当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。 
但从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。
使用长连接的 HTTP协议，会在响应头有加入这行代码：Connection:keep-alive 
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP 数据的 TCP 连接不会关闭。
如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。
实现长连接要客户端和服务端都支持长连接。 
HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。 

HTTP 的 Keep-Alive 和 TCP 的 Keep-Alive 有些不同，两个意图不一样。
前者主要是 TCP 连接复用，避免建立过多的 TCP 连接。
而 TCP 的 Keep-Alive 的意图是在于保持 TCP 连接的存活，就是发送心跳包，隔一段时间给连接对端发送一个探测包，
如果接收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。 

# DNS 解析的过程
1. 在浏览器中输入 www.qq.com 域名，操作系统会先检查自己本地的 hosts 文件
是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。 
2. 如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这
个网址映射关系，如果有，直接返回，完成域名解析。 
3. 如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找
TCP/IP 参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服
务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析
结果给客户机，完成域名解析，此解析具有权威性。 
4. 如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此
网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。 
5. 如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服
务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把
请求发至 “根 DNS 服务器”，“根 DNS 服务器”收到请求后会判断这个域名(.com)
是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP。本地 DNS 服
务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责.com 域的服
务器收到请求后，如果自己无法解析，它就会找一个管理.com 域的下一级 DNS
服务器地址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，
就会找 qq.com 域服务器，重复上面的动作，进行查询，直至找到 www.qq.com 主机。 
6. 如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，
由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请
求转至上上级，以此循环。不管本地 DNS 服务器用的是转发，还是根提示，最
后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。 

所谓 递归查询过程 就是 “查询的递交者” 更替, 而 迭代查询过程 则是 “查询
的递交者”不变。 
